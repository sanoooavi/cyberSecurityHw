## RCX
| RCX    |       |
|--------------|---------------------------------------------|
| Block size   |    8    bit                                     |
| Key size     |      128 bit                             |
| number of rounds       | 12                                       |

### Key scheduling
The key scheduling algorithm initializes an array of subkeys that will be used in the encryption and decryption process.

![My Image](https://github.com/sanoooavi/cyberSecurityHw/blob/main/CRX/images/Untitled-Page-1.png)


1. **Constants Initialization**:
   - `P_w` and `Q_w` are constants derived from the binary expansion of e and the golden ratio respectively. These are used to initialize the subkeys.

   ```python
   P_w = 0xB7E15163
   Q_w = 0x9E3779B9
   ```

2. **Key Expansion**:
   - The input key `K` is expanded into an array `L` of `c` 32-bit words.
   - `u` is the number of bytes in a word (`w // 8`, which is 4 for 32-bit words).
   - `b` is the length of the key in bytes.
   - `c` is the number of words needed to store the key.

   ```python
   u = w // 8  # u = 4
   b = len(K)  # b = 16 bytes (128 bits)
   c = (b + u - 1) // u  # c = 4
   L = [0] * c
   for i in range(b - 1, -1, -1):
       L[i // u] = (L[i // u] << 8) + K[i]
   ```

3. **Subkeys Initialization**:
   - An array `S` of `t` subkeys is initialized. `t` is `2 * (r + 1)`, where `r` is the number of rounds.
   - The first subkey `S[0]` is set to `P_w`.
   - The remaining subkeys are generated by adding `Q_w` successively and taking modulo `2^w` to fit within `w` bits.

   ```python
   S = [0] * t
   S[0] = P_w
   for i in range(1, t):
       S[i] = (S[i - 1] + Q_w) % (1 << w)
   ```

4. **Mixing in the Key**:
   - The key array `L` is mixed into the subkeys `S`.

   ```python
   for i in range(t):
       S[i] = (S[i] + L[i % c]) % (1 << w)
   ```

### Round function
![My Image](https://github.com/sanoooavi/cyberSecurityHw/blob/main/CRX/images/round_function.png)

### Block encryption

1. **Initialization**:
   - The plaintext block is divided into two 4-bit halves, `A` and `B`.
   - Initial values of `A` and `B` are mixed with the first two subkeys.

   ```python
   A, B = permutation(block[0], block[1])
   A = (A + S[0]) % (1 << w)
   B = (B + S[1]) % (1 << w)
   ```

2. **Rounds**:
   - The encryption process iterates for `r` rounds. In each round:
     - `A` is updated using a combination of XOR with `B` and addition of a subkey.
     - `B` is updated using a combination of XOR with the new value of `A` and addition of another subkey.

   ```python
   for i in range(1, r + 1):
       A = (A ^ B) + S[2 * i] % (1 << w)
       B = (B ^ A) + S[2 * i + 1] % (1 << w)
   ```

3. **Final Permutation**:
   - After all rounds, a final permutation swaps `A` and `B`.

   ```python
   return permutation(A, B)
   ```

![My Image](https://github.com/sanoooavi/cyberSecurityHw/blob/main/CRX/images/RCX.png)

### Design
![My Image](https://github.com/sanoooavi/cyberSecurityHw/blob/main/CRX/images/design.png)


